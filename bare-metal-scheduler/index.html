<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Building a Bare Metal Scheduler on an STM32H7 — Lab Notes</title>
    <style>
        :root {
            --bg: #fdfdfd;
            --fg: #222;
            --dim: #666;
            --border: #ddd;
            --code-bg: #f5f5f5;
            --link: #1a6fb5;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #151515;
                --fg: #aaa;
                --dim: #888;
                --border: #333;
                --code-bg: #1e1e1e;
                --link: #6fb8e0;
                --em: #ccc;
            }
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            font-size: 15px;
            line-height: 1.7;
            color: var(--fg);
            background: var(--bg);
            max-width: 720px;
            margin: 0 auto;
            padding: 60px 24px;
        }
        nav { margin-bottom: 48px; }
        nav a { color: var(--dim); text-decoration: none; font-size: 13px; }
        nav a:hover { color: var(--fg); }
        h1 {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        .meta {
            color: var(--dim);
            font-size: 13px;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        h2 {
            font-size: 17px;
            font-weight: 700;
            margin: 36px 0 12px;
        }
        h3 {
            font-size: 15px;
            font-weight: 700;
            margin: 28px 0 8px;
        }
        p { margin: 12px 0; text-align: justify; }
        em {
            color: var(--em, inherit);
            font-style: italic;
            font-family: 'Georgia', 'Times New Roman', serif;
        }
        a { color: var(--link); }
        pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 16px 0;
            font-size: 13px;
            line-height: 1.5;
        }
        code {
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            font-size: 13px;
        }
        p code {
            background: var(--code-bg);
            padding: 2px 5px;
            border-radius: 3px;
        }
        img {
            max-width: 100%;
            margin: 16px 0;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        blockquote {
            border-left: 3px solid var(--border);
            padding-left: 16px;
            color: var(--dim);
            margin: 16px 0;
        }
        table {
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 13px;
        }
        th, td {
            border: 1px solid var(--border);
            padding: 8px 12px;
            text-align: left;
        }
        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 32px 0;
        }
        .toc {
            margin: 0 0 32px;
            padding: 16px 20px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 13px;
        }
        .toc h2 {
            font-size: 14px;
            margin: 0 0 8px;
        }
        .toc ul {
            list-style: none;
            padding-left: 0;
        }
        .toc ul ul {
            padding-left: 16px;
        }
        .toc li {
            margin: 4px 0;
        }
        .toc a {
            color: var(--dim);
            text-decoration: none;
        }
        .toc a:hover {
            color: var(--fg);
        }
    </style>
</head>
<body>
    <nav><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes">← lab-notes</a></nav>
    <h1>Building a Bare Metal Scheduler on an STM32H7</h1>
    <div class="meta">2026-02-08</div>

    
    <nav class="toc">
        <h2>Contents</h2>
        <ul>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#starting-situation">Starting situation</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#the-problem">The problem</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#building-and-running-code-on-the-st32h7">Building and running code on the ST32H7</a>
            
            <ul>
                
                <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#target-board">Target Board</a></li>
                
                <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#helpful-information">Helpful information</a></li>
                
                <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#compiling">Compiling</a></li>
                
                <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#linking">Linking</a></li>
                
                <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#building-an-executable">Building an Executable</a></li>
                
            </ul>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#blinky-example">Blinky example</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#your-three-best-friends">Your three best friends</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#leveling-up-switching-from-asm-to-c">Leveling up | switching from asm to C</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#execution-context">Execution context</a>
            
            </li>
        
            <li><a href="https:&#x2F;&#x2F;janthies.github.io&#x2F;lab-notes&#x2F;bare-metal-scheduler&#x2F;#looking-forward">Looking forward</a>
            
            </li>
        
        </ul>
    </nav>
    

    <h1 id="starting-situation">Starting situation</h1>
<p>As a weekend project I decided to give bare metal programming a shot. What started with some basic blinking of an led
and firing an interrupt when a button is pressed turned into writing a small task switcher / scheduler.
In this post I hope to take you along the path I took, the challgenges I encountered and how i overcame them.</p>
<p>In order to appreciate this post you should probably be familiar with the C programming language. I am not talking about crazy macro expansions
and the like but declaring structs, dealing with pointers and  passing functions as arguments to other functions shouldn't be too unfamiliar.
Knowing a thing or two about computer architecture and what a register is would be helpful too.</p>
<p>// TODO
getting in contact</p>
<p>errata</p>
<h1 id="the-problem">The problem</h1>
<p>Bare metal programming is fun. It is just you, your development board and a 3357 page reference manual written in dense and technical prose.</p>
<h1 id="building-and-running-code-on-the-st32h7">Building and running code on the ST32H7</h1>
<p>If you have done something with an Arduino before you might be familiar with the term <strong>flashing</strong>.
Flashing describes the process of writing executable program code to the Read Only Memory (ROM) of our Microcontroller Unit (MCU). Now there are two major
problems to solve. How do we get executable code and how do we flash it to our MCU?</p>
<h2 id="target-board">Target Board</h2>
<p>The board I use is an STM32 <a rel="external" href="https://www.st.com/en/evaluation-tools/nucleo-h723zg.html">Nucleo-H723ZG</a> as shown in the photo below.
<img src="https://janthies.github.io/lab-notes/bare-metal-scheduler/nucleo.png" alt="test" />
Now inside the red box is
what we care about. It is the <a rel="external" href="https://www.st.com/en/microcontrollers-microprocessors/stm32h723-733.html">STM32H723 MCU</a>. The MCU itself then contains
a single Arm Cortex-M7 core running at up to 550MHz. Apart from that the MCU also contains the FLASH memory that, for all intents and purposes serves as our ROM.
Yes, we write to Read Only Memory, welcome to the world of embedded programming.</p>
<p>Now inside the blue box is something interesting, it is another MCU! <em>Wait!</em> you might say. <em>Didn't you just tell me that there's only a single core processor?
But now two processors? That doesn't make sense!</em> Well, I'm sure this is obvious to some but being precise with the language being used is of importance here.
The white Printed Circuit Board (PCB) you can see is the <strong>Development Board</strong>. It contains our MCU (red rectangle) but also a whole bunch of other peripherals.
In the green rectangle are some LEDs that are connected to the MCU and can be lit up on demand. The MCU itself now contains a processing
core, namely an ARM Cortex-M7. In order for us to have an easier time talking to our MCU, the MCU in the blue rectangle is running a software called <strong>ST-Link</strong>.
At a later stage, ST-Link will help us flash some executable code from our computer to the MCU in the red rectangle, our target chip. If the second
MCU were not there, we would need special hardware for communicating with our MCU.</p>
<h2 id="helpful-information">Helpful information</h2>
<p>Most if not all of the things I convey in this post I have read in the documentation and datasheets regarding the hardware in question. I would like to point
out the relevant documents once more because knowing where to find relevant and original information is what will help you understand most.</p>
<p>The <a rel="external" href="https://www.st.com/resource/en/user_manual/um2407-stm32h7-nucleo144-boards-mb1364-stmicroelectronics.pdf">Nucleo-H723ZG user manual</a> contains plenty of useful
information regarding the development board. Here we can find information regarding the flashing process, pin connections and more.</p>
<p>The <a rel="external" href="https://www.st.com/resource/en/reference_manual/rm0468-stm32h723733-stm32h725735-and-stm32h730-value-line-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32H723 reference manual</a>
was the most daunting document for me when starting out because of its 3000+ page count. Register addresses, offsets, usage, the functional description of certain hardware blocks,
documentation on all peripherals, the clock tree. This document has it all. Knowing where to look in order to find relevant information can be a bit challengeing but once gets used to it.</p>
<p>Next we have the <a rel="external" href="https://documentation-service.arm.com/static/61efd6602dd99944d051417b?token=">Cortex-M7 generic user guide</a> and the <a rel="external" href="https://documentation-service.arm.com/static/5e906b038259fe2368e2a7bb?token=">Cortex-M7 technical reference manual</a>.
Whenever we need to find processor core specific documentation, this is the go to source.</p>
<p>Lastly, knowing the differences between the Cortex-M7 and the STM32H723 can be a bit confusing at first. The Cortex-M7 is the processor core, doing the computation. The STM32H7
is our <strong>System on Chip (SoC)</strong>. The SoC contains the Cortex-M7, furthermore it contains FLASH storage that can hold our executable code. RAM that serves as the working memory
for the core. Different functional blocks like the USART block for transceiving serial data or the EXTI block for interrupt handling.</p>
<p>When the need arises, we will go much deeper on each individual topic.
For now, having a grasp on the different levels of abstraction we are dealing with and where to find relevant information should suffice.</p>
<h2 id="compiling">Compiling</h2>
<p>Compiling our code for the target platform is the next step. In the world of embedded we usually talk about <strong>cross-compilation</strong> because the computer
we write and compile the code on is usually somewhat different from the platform we are targetting. As a little experiment, running <em>lscpu</em> give the following output:</p>
<pre class="giallo" style="color: #CDD6F4; background-color: #1E1E2E;"><code data-lang="c"><span class="giallo-l"><span>jan@jan:</span><span style="color: #94E2D5;">~</span><span>$ lscpu</span></span>
<span class="giallo-l"><span>Architecture:                x86_64</span></span>
<span class="giallo-l"><span>  CPU op</span><span style="color: #94E2D5;">-</span><span style="color: #89B4FA;font-style: italic;">mode</span><span style="color: #9399B2;">(</span><span>s</span><span style="color: #9399B2;">)</span><span>:            </span><span style="color: #FAB387;">32</span><span style="color: #94E2D5;">-</span><span>bit</span><span style="color: #9399B2;">,</span><span style="color: #FAB387;"> 64</span><span style="color: #94E2D5;">-</span><span>bit</span></span>
<span class="giallo-l"><span>  Address sizes:             </span><span style="color: #FAB387;">39</span><span> bits physical</span><span style="color: #9399B2;">,</span><span style="color: #FAB387;"> 48</span><span> bits virtual</span></span>
<span class="giallo-l"><span style="color: #F9E2AF;font-style: italic;">  Byte</span><span> Order:                Little Endian</span></span>
<span class="giallo-l"><span style="color: #89B4FA;font-style: italic;">CPU</span><span style="color: #9399B2;">(</span><span>s</span><span style="color: #9399B2;">)</span><span>:                      </span><span style="color: #FAB387;">8</span></span>
<span class="giallo-l"><span>  On</span><span style="color: #94E2D5;">-</span><span>line </span><span style="color: #89B4FA;font-style: italic;">CPU</span><span style="color: #9399B2;">(</span><span>s</span><span style="color: #9399B2;">)</span><span> list:       </span><span style="color: #FAB387;">0</span><span style="color: #94E2D5;">-</span><span style="color: #FAB387;">7</span></span>
<span class="giallo-l"><span>Vendor ID:                   GenuineIntel</span></span>
<span class="giallo-l"><span>  Model name:                11th Gen </span><span style="color: #89B4FA;font-style: italic;">Intel</span><span style="color: #9399B2;">(</span><span>R</span><span style="color: #9399B2;">)</span><span style="color: #89B4FA;font-style: italic;"> Core</span><span style="color: #9399B2;">(</span><span>TM</span><span style="color: #9399B2;">)</span><span> i7</span><span style="color: #94E2D5;">-</span><span>1165G7 @ 2.80GHz</span></span>
<span class="giallo-l"><span>  ...</span></span>
<span class="giallo-l"></span></code></pre>
<p>Now we can see that the architecture is x86_64. Taking a look at the <a rel="external" href="https://documentation-service.arm.com/static/5e906b038259fe2368e2a7bb?token=">ARM Cortex-m7 reference manual</a>
we find under section <em>1.4.1</em> that this processor is implementing the Armv7E-M architecture. That is quiet different from my pc! The architecture, more formally known as
an <strong>Instruction Set Architecture</strong> is the interface between the software we write and the hardware that is going to execute it. We need to find a compiler that translates
our already architecture specific assembly code, and later also our architecture agnostic C code, into machine that can be executed by the STM32H7.</p>
<h3 id="writing-the-code-that-brings-our-mcu-to-life">Writing the code that brings our MCU to life</h3>
<p>The code I am talking about is so called startup code. This is the code that runs first and configures our MCU in a usable way.
Taking a look in the <a rel="external" href="https://documentation-service.arm.com/static/61efd6602dd99944d051417b?token=">generic user guide</a> for our
ARM Cortex-M7, we can find some words regarding the reset behaviour of our chip in section 2.1.3. Skipping past the core registers
we find the following text:</p>
<p><em>The Program Counter (PC) is register R15. It contains the current program address. On reset, the processor loads the PC with the value
of the reset vector, which is at the initial value of the Vector Table Offset Register (VTOR) plus 0x00000004.
Bit[0] of the value is loaded into the EPSR T-bit at reset and must be 1</em>.</p>
<p>Now this is interesting and tells us exactly what to do! The second we give electrical power to our MCU, it looks at a specific memory address,
loads the data at that memory address into the <strong>Program Counter</strong> and then continues executing from there. Now the program counter tells us which command the
MCU is currently executing. The text also mentioned the <strong>Reset Vector</strong>. The reset vector is a routine whose address we would like to store in that specific
memory address, so that it runs right away when the system first receives power.</p>
<p>A bit further down under section 2.3.4 we can read about the <strong>Vector Table</strong>. The vector table is an area in memory that stores a bunch of important addresses
to routines the MCU would like to execute in certain scenarios. Those scenarios include system reset, different fault conditions we might want to recover from
but also repeating time intervals that might remember us to do something.</p>
<p><strong>Vector Table of the Cortex-M7</strong></p>
<p><img src="https://janthies.github.io/lab-notes/bare-metal-scheduler/vector_table.png" alt="Vector Table" />
In the vector table we can see that our reset vector is at offset 0x0004. That is 32 bit above the Initial Stack Pointer Value entry which is located at offset 0x0000. <em>Offset?</em>
you might wonder. Yeah exactly, we now know the location of our reset vector and initial SP relative to the vector table but the vector table itself is located at a different location.</p>
<p>arm-none-eabi-as
arm-none-eabi-gcc</p>
<h3 id="inspecting-the-code-we-just-created">Inspecting the code we just created</h3>
<p>arm-none-eabi-objdump</p>
<h2 id="linking">Linking</h2>
<h2 id="building-an-executable">Building an Executable</h2>
<p>how to get code running on an embedded device</p>
<p>basic sections</p>
<p>reset handler</p>
<h1 id="blinky-example">Blinky example</h1>
<p>reading the reference sheet</p>
<p>configuring and writing to some basic registers</p>
<h1 id="your-three-best-friends">Your three best friends</h1>
<p>memory map / clock tree / gdb</p>
<h1 id="leveling-up-switching-from-asm-to-c">Leveling up | switching from asm to C</h1>
<p>more about sections</p>
<p>crt0</p>
<h1 id="execution-context">Execution context</h1>
<p>what does a task need to execute</p>
<p>how to configure a tasks context</p>
<p>how to load and store a task</p>
<h1 id="looking-forward">Looking forward</h1>
<pre class="giallo" style="color: #CDD6F4; background-color: #1E1E2E;"><code data-lang="c"><span class="giallo-l"><span style="color: #CBA6F7;">void</span><span style="color: #89B4FA;font-style: italic;"> scheduler_init</span><span style="color: #9399B2;">(</span><span style="color: #CBA6F7;">void</span><span style="color: #9399B2;">) {</span></span>
<span class="giallo-l"><span style="color: #9399B2;font-style: italic;">    // ...</span></span>
<span class="giallo-l"><span style="color: #9399B2;">}</span></span></code></pre><pre class="giallo" style="color: #CDD6F4; background-color: #1E1E2E;"><code data-lang="plain"><span class="giallo-l"></span>
<span class="giallo-l"><span>**For images**, put them next to your post by using a &quot;page directory&quot; instead of a standalone `.md` file:</span></span></code></pre>
<p>content/
bare-metal-scheduler/
index.md          ← your post
scheduler-diagram.png
memory-layout.png</p>

</body>
</html>
